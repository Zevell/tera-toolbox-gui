const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

function forcedirSync(dir) {
    const sep = path.sep;
    const initDir = path.isAbsolute(dir) ? sep : '';
    dir.split(sep).reduce((parentDir, childDir) => {
        const curDir = path.resolve(parentDir, childDir);
        try {
            fs.mkdirSync(curDir);
        } catch (_) {
            // Ignore
        }

        return curDir;
    }, initDir);
}

function rmdirSyncForce(dir_path) {
    if (!fs.existsSync(dir_path))
        return;

    fs.readdirSync(dir_path).forEach(entry => {
        const entry_path = path.join(dir_path, entry);
        if (fs.lstatSync(entry_path).isDirectory())
            rmdirSyncForce(entry_path);
        else
            fs.unlinkSync(entry_path);
    });
    fs.rmdirSync(dir_path);
}

function hash(data) {
    return crypto.createHash("sha256").update(data).digest().toString("hex").toUpperCase();
}

class GPKManager {
    constructor(GPKFolderName) {
        this.GPKFolderName = GPKFolderName;
        this.installedFiles = {};
    }

    destructor() {

    }

    getGPKFolderPath(clientFolder) {
        return path.join(clientFolder, 'S1Game', 'CookedPC', this.GPKFolderName);
    }

    getFullPath(clientFolder, filename) {
        return path.join(this.getGPKFolderPath(clientFolder), filename);
    }

    initialize(clientFolder) {
        if (this.hasInstalled(clientFolder))
            return;

        rmdirSyncForce(this.getGPKFolderPath(clientFolder));
    }

    hasInstalled(clientFolder) {
        const folder = this.getGPKFolderPath(clientFolder);
        return Object.keys(this.installedFiles).some(filename => filename.startsWith(folder));
    }

    getInstalled(clientFolder) {
        const folder = this.getGPKFolderPath(clientFolder);
        return Object.keys(this.installedFiles).filter(filename => filename.startsWith(folder));
    }

    install(clientFolder, filename, fromPath) {
        const fromContents = fs.readFileSync(fromPath);
        const fromHash = hash(fromContents);

        const fullPath = this.getFullPath(clientFolder, filename);
        if (this.installedFiles[fullPath]) {
            if (this.installedFiles[fullPath].hash !== fromHash)
                throw new Error(`Trying to install two different GPK files with the same name: ${fullPath}`);

            ++this.installedFiles[fullPath].count;
        } else {
            forcedirSync(path.dirname(fullPath));
            fs.writeFileSync(fullPath, fromContents);

            this.installedFiles[fullPath] = {
                hash: fromHash,
                count: 1,
            };
        }
    }

    uninstall(clientFolder, filename) {
        this._uninstall(this.getFullPath(clientFolder, filename));
    }

    _uninstall(fullPath) {
        if (!this.installedFiles[fullPath])
            return;

        if (this.installedFiles[fullPath].count > 1) {
            --this.installedFiles[fullPath].count;
        } else {
            fs.unlinkSync(fullPath);
            delete this.installedFiles[fullPath];
        }
    }

    uninstallAll(clientFolder) {
        this.getInstalled(clientFolder).forEach(fullPath => this._uninstall(fullPath));
        if (!this.hasInstalled(clientFolder))
            rmdirSyncForce(this.getGPKFolderPath(clientFolder));
    }
}

module.exports = GPKManager;
